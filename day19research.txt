// opcodes
addr = r[a] + r[b]
addi = r[a] + b
mulr = r[a] * r[b]
muli = r[a] * b
banr = r[a] & r[b]
bani = r[a] & b
borr = r[a] | r[b]
bori = r[a] | b
setr = r[a]
seti = a
gtir = a > r[b]
grti = r[a] > b
gtrr = r[a] > r[b]
eqir = a == r[b]
eqri = r[a] == b
eqrr = r[a] == r[b]

// registers
r[0] result
r[1] instruction pointer
r[2] outer loop
r[3] inner loop
r[4] comparison
r[5] limit

// loop sample
[0, 2, 1, 2, 0, 896]
[0, 2, 1, 3, 0, 896]
[0, 2, 1, 4, 0, 896]
[0, 2, 1, 5, 0, 896]
[0, 2, 1, 6, 0, 896]
[0, 2, 1, 7, 0, 896]
[0, 2, 1, 8, 0, 896]
[0, 2, 1, 9, 0, 896]
[0, 2, 1, 10, 0, 896]
[0, 2, 1, 11, 0, 896]
[0, 2, 1, 12, 0, 896]
[0, 2, 1, 13, 0, 896]

// python loop
for r2 in range(1, r[5] + 1):
    for r3 in range(1, r[5] + 1):
        r[2] = r2
        r[3] = r3
        if r[2] * r[3] == r[5]:
            r[0] += r[2]
        if r[2] == r[5]:
            r[1] = 15

// the program
  0 addi 1 16 1 // jumpi 17
> 1 seti 1 4 2  // r[2] = 1
> 2 seti 1 0 3  // r[3] = 1
> 3 mulr 2 3 4  // r[4] = r[2] * r[3]
  4 eqrr 4 5 4  // if r[2] * r[3] == r[5]:
  5 addr 4 1 1  //   jumpi 7
  6 addi 1 1 1  // jumpi 8
> 7 addr 2 0 0  // r[0] += r[2]
> 8 addi 3 1 3  // r[3] += 1
  9 gtrr 3 5 4  // if r[3] > r[5]:
 10 addr 1 4 1  //   jumpi 12
 11 seti 2 4 1  // jumpi 3

>12 addi 2 1 2  // r[2] += 1
 13 gtrr 2 5 4  // if r[2] > r[5]:
 14 addr 4 1 1  //   jumpi 16
 15 seti 1 1 1  // jumpi 2

>16 mulr 1 1 1  // jumpi 64  HALT

// r[5] = (r[5] + 2) * 2 * 19 * 11
>17 addi 5 2 5  // r[5] += 2
 18 mulr 5 5 5  // r[5] *= r[5]
 19 mulr 1 5 5  // r[5] *= 19
 20 muli 5 11 5 // r[5] *= 11

// r[4] = (r[4] + 2) * 22 * 16
 21 addi 4 2 4  // r[4] += 2
 22 mulr 4 1 4  // r[4] *= 22
 23 addi 4 16 4 // r[4] += 16

 24 addr 5 4 5  // r[5] += r[4]
 25 addr 1 0 1  // jumpi 26 or 27 (part 1 and part 2)

>26 seti 0 7 1  // jumpi 1 

// r[4] = ((27 * 28) + 29) * 30 * 14 * 32
>27 setr 1 5 4  // r[4] = 27
 28 mulr 4 1 4  // r[4] *= 28
 29 addr 1 4 4  // r[4] += 29
 30 mulr 1 4 4  // r[4] *= 30
 31 muli 4 14 4 // r[4] *= 14
 32 mulr 4 1 4  // r[4] *= 32

 33 addr 5 4 5  // r[5] += r[4]
 34 seti 0 9 0  // r[0] = 0
 35 seti 0 4 1  // jumpi 1

// test run
0 ip=0 [1, 0, 0, 0, 0, 0] addi 1 16 1 [1, 16, 0, 0, 0, 0]
1 ip=17 [1, 17, 0, 0, 0, 0] addi 5 2 5 [1, 17, 0, 0, 0, 2]
2 ip=18 [1, 18, 0, 0, 0, 2] mulr 5 5 5 [1, 18, 0, 0, 0, 4]
3 ip=19 [1, 19, 0, 0, 0, 4] mulr 1 5 5 [1, 19, 0, 0, 0, 76]
4 ip=20 [1, 20, 0, 0, 0, 76] muli 5 11 5 [1, 20, 0, 0, 0, 836]
5 ip=21 [1, 21, 0, 0, 0, 836] addi 4 2 4 [1, 21, 0, 0, 2, 836]
6 ip=22 [1, 22, 0, 0, 2, 836] mulr 4 1 4 [1, 22, 0, 0, 44, 836]
7 ip=23 [1, 23, 0, 0, 44, 836] addi 4 16 4 [1, 23, 0, 0, 60, 836]
8 ip=24 [1, 24, 0, 0, 60, 836] addr 5 4 5 [1, 24, 0, 0, 60, 896]
9 ip=25 [1, 25, 0, 0, 60, 896] addr 1 0 1 [1, 26, 0, 0, 60, 896]
10 ip=27 [1, 27, 0, 0, 60, 896] setr 1 5 4 [1, 27, 0, 0, 27, 896]
11 ip=28 [1, 28, 0, 0, 27, 896] mulr 4 1 4 [1, 28, 0, 0, 756, 896]
12 ip=29 [1, 29, 0, 0, 756, 896] addr 1 4 4 [1, 29, 0, 0, 785, 896]
13 ip=30 [1, 30, 0, 0, 785, 896] mulr 1 4 4 [1, 30, 0, 0, 23550, 896]
14 ip=31 [1, 31, 0, 0, 23550, 896] muli 4 14 4 [1, 31, 0, 0, 329700, 896]
15 ip=32 [1, 32, 0, 0, 329700, 896] mulr 4 1 4 [1, 32, 0, 0, 10550400, 896]
16 ip=33 [1, 33, 0, 0, 10550400, 896] addr 5 4 5 [1, 33, 0, 0, 10550400, 10551296]
17 ip=34 [1, 34, 0, 0, 10550400, 10551296] seti 0 9 0 [0, 34, 0, 0, 10550400, 10551296]
18 ip=35 [0, 35, 0, 0, 10550400, 10551296] seti 0 4 1 [0, 0, 0, 0, 10550400, 10551296]
